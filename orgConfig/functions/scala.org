* Scala

  Functions used specifically for dealing with scala code.
  It depends on the functions defined into `languageTemplateFunctions.org`

#+BEGIN_SRC emacs-lisp :tangle yes
(defun sbt-event-file-navigation (&optional notSplitWindow)
  "Navigate to the file that has a problem. it can navigate using a
  different window."
  (funcall 'event-file-navigation "] " ":" notSplitWindow)
  )

(defun scala-build-import-ag (inputType)

  (defun existingImportInPorject (importPrefix importSuffix agBufferName type)
    (switch-to-existing-buffer-other-window agBufferName)
    (compilation-next-error 1)
    (search-forward ":" nil nil 2)
    (setq missingTypeStartingPoint (point))
    (end-of-line)
    (setq result (concat importPrefix (buffer-substring-no-properties missingTypeStartingPoint (point)) importSuffix))
    (eval result)
    )

  (defun importFromPackage (importPrefix importSuffix agBufferName type)
    (switch-to-existing-buffer-other-window agBufferName)
    (setq filePath (funcall 'ag-parsing-first-error-file-path))
    (find-file filePath)
    (beginning-of-buffer)
    (search-forward "package ")
    (setq missingTypeStartingPoint (point))
    (end-of-line)
    (setq
     package (buffer-substring-no-properties missingTypeStartingPoint (point))
     result (concat importPrefix package "." type))
    (eval result)
    )

  (defun searchImportFallback (agBufferName regexpFallbackSearch importPrefix importSuffix agFallbackBufferName type startingBuffer)
    (switch-to-existing-buffer-other-window agBufferName)
    (setq result nil
          currentBuffer (buffer-name))
    (switch-to-buffer startingBuffer)
    (ag-project-regexp regexpFallbackSearch)
    (set-process-sentinel
     (get-process "ag")
     (lexical-let (
                   (agBufferName agBufferName)
                   (regexpFallbackSearch regexpFallbackSearch)
                   (importPrefix importPrefix)
                   (importSuffix importSuffix)
                   (agFallbackBufferName agFallbackBufferName)
                   (type type)
                   )
       (lambda (p e)
         (cond
          ((string= e "finished\n")
           (setq result (funcall 'importFromPackage importPrefix importSuffix agFallbackBufferName type)))
          ))))
    (while (accept-process-output (get-process "ag") 0.5))
    (switch-to-buffer currentBuffer)
    (eval result)
    )

  (setq missingTypeImport nil
        windowNumber (count-windows)
        )
  (ag-project-regexp (concat "import.*\\." inputType "$"))
  (set-process-sentinel
   (get-process "ag")
   (lexical-let (
                 (type inputType)
                 (bufferName (buffer-name))
                 )
     (lambda (p e)
       (cond
        ((string= e "finished\n") (funcall 'existingImportInPorject "import " "" "*ag search regexp:import" type))
        ((string-prefix-p "exited abnormally" e ())
         (setq missingTypeImport
               (funcall
                'searchImportFallback
                "*ag search regexp:import"
                (concat "(.*object " type ".*|.*class " type ".*|.*trait " type ".*|.*type " type ".*)")
                "import "
                ""
                "*ag search regexp:(.*"
                type
                bufferName
                )))
        ))))
  (while (accept-process-output (get-process "ag") 0.5))
  (when (/= (count-windows) windowNumber) (delete-window))
  (switch-to-buffer startingBuffer)
  (kill-matching-buffers "*ag search regexp:" nil t)
  (eval missingTypeImport)
  )

(defun path-to-package (path)
  "transferm a path to a package"
  (interactive)
  (string-join
   (butlast
    (s-split "/"
             (nth 1
                  (split-string path "scala/")
                  )
             )
    ) ".")
  )

; keybinded functions ;;;;;;;;;;;;;;;;;
(defun sbt-shell-clean-old-output ()
  "When called on a shell buffer this function goes back to the beginning of the last compilation and delete the rest (old compilation)"
  (interactive)
  (funcall 'shell-clean-old-output "[info] Compiling")
  )

(defun scala-goto-next-warn-error (&optional errorMessage backwardSearch)
  "Search into an sbt output for the first warning/error, starting from cursor position, and move to it"
  (interactive)
  (unless errorMessage (setq errorMessage ""))
  (setq searchRegexp (concat ".*\\.scala.*" (regexp-quote errorMessage)))
  (condition-case
      nil
      (funcall (searchFunction backwardSearch) searchRegexp)
    (error (user-error "no match found for %s" errorMessage))
    )
  (sbt-event-file-navigation t)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'goto-line)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'right-char)
  )

(defun scala-remove-unused-import ()
  "Parse a shell/sbt output in search of the first unused import and remove it"
  (interactive)
  (funcall 'scala-goto-next-warn-error "Unused Import" t)
  (setq bracketImport (line-contains-string ",")
        importPos (save-excursion (search-backward "import ") (point)))
  (if bracketImport
      (progn
        (let (p1 p2 afterComma)
          (condition-case
              nil
              (search-backward "," importPos)
            (error
             (search-backward "{" importPos)
             (forward-char)
             (setq afterComma t)
             )
            )

          (setq p1 (point))
          (forward-word)
          (setq p2 (point))
          (when afterComma (setq p2 (1+ p2)))
          (kill-region p1 p2)))
    (progn
      (beginning-of-line)
      (kill-line)
      (delete-char -1) ;; kill newline
      ;; delete the comma from the previous element of imports
      (when (string= (string (char-before)) ",") (delete-char -1))
      ))
  (setq bracket t)
  (condition-case
      nil
      (search-backward "{")
    (error
     (setq bracket nil)
     )
    )
  (when (and bracket (> (point) importPos))
    (progn
      (setq openBracketPos (point))
      (search-forward "}")
      (setq closedBracketPos (point))
      (setq remainingImports (s-count-matches "\\w+" (buffer-substring openBracketPos closedBracketPos)))
      (message "remainingImports " remainingImports)
      (cond
       (
        (= 0 remainingImports)
        (progn ;; Cleanup import with empty brackets
          (kill-region openBracketPos closedBracketPos)
          (goto-char importPos)
          (beginning-of-buffer)
          (kill-line)
          (delete-char -1)
          ))
       (
        (= 1 remainingImports)
        (save-restriction
          (narrow-to-region importPos closedBracketPos)

          ;; all on one line, only one import remained
          ;; Just join 2 lines together works
          (while (not (= (line-number-at-pos importPos)
                         (line-number-at-pos closedBracketPos)))
            (progn
              (goto-char closedBracketPos)
              (join-line)
              (setq closedBracketPos (point))
              )
            )

          (beginning-of-line)
          (while (search-forward "{" nil t)
            (replace-match ""))
          (beginning-of-line)
          (while (search-forward "}" nil t)
            (replace-match ""))
          (beginning-of-line)
          (search-forward "import ")
          (while (search-forward " " nil t)
            (replace-match ""))
          ))
       )))
  (other-window -1)
  )

(defun scala-import-type-at-point (type)
  "Try to import into the current file the type at point"
  (interactive (list
                (read-string (format "type (%s): " (thing-at-point 'word))
                             nil nil (thing-at-point 'word))))

  (setq startingBuffer (current-buffer)
        importToAdd (funcall 'scala-build-import-ag type))

  (if importToAdd
      (save-excursion
        (switch-to-buffer startingBuffer)
        (beginning-of-buffer)
        (forward-line)
        (newline)
        (insert importToAdd))
    (user-error "Unable to find import for the type %s" type)
    )
  )

(defun scala-extract-code-line-or-region (name &optional parameters from to)
  "Extract the code to val or def:
   Require:
     - Name of the val/def
     - Optional list of parameters (if empty it will be a val)

   if no code region is selected then it extracts the rest of the line from current position
   Return type not specified.
  "
  (interactive (list
                (read-string "value/function name: " )
                (progn
                  (setq
                   separator (read-string "insert separartor(,): " nil nil ",")
                   param (read-string "param name (RET to finish): ")
                   params nil
                   )
                  (while (not (equal "" (s-trim param)))
                    (push (s-trim param) params)
                    (setq param (read-string "param name (RET to finish): "))
                    )
                  (reverse (cons (car params) (mapcar (lambda (x) (concat x separator)) (cdr params))))
                  )
                (if (use-region-p) (region-beginning) (point))
                (if (use-region-p) (region-end) (line-end-position))
                ))
  (funcall 'extract-code-line-or-region-template "val " "def " " = " " = " nil nil name parameters from to)
  )

(global-set-key (kbd "C-c c s c") 'sbt-shell-clean-old-output)
(global-set-key (kbd "C-c c s e") 'scala-goto-next-warn-error)
(global-set-key (kbd "C-c c s u") 'scala-remove-unused-import)
(global-set-key (kbd "C-c c s p") 'scala-import-type-at-point)
(global-set-key (kbd "C-c c s x") 'scala-extract-code-line-or-region)

#+END_SRC
