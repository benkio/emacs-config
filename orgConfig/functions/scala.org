* Scala

  Functions used specifically for dealing with scala code.
  It depends on the functions defined into `languageTemplateFunctions.org`

#+BEGIN_SRC emacs-lisp :tangle yes
(defun sbt-event-file-navigation (&optional notSplitWindow)
  "Navigate to the file that has a problem. it can navigate using a
  different window."
  (funcall 'event-file-navigation "] " ":" notSplitWindow)
  )

(defun scala-build-import-from-existing-import-or-source (type startingBuffer)
  "Considering the cursor is at the beginning of the target import line
   or into the scala source file containing the definition of the
  target file. This functions return the import to insert into the
  dependent scala source file."
  (if (string= (current-word) "import")
      (copy-line-from-point-as-string) ;; copy import line
    (concat "import " (path-to-package (buffer-file-name)) "." type) ;; copy package and make it an import
    )
  )

(defun path-to-package (path)
  "transferm a path to a package"
  (interactive)
  (string-join
   (butlast
    (s-split "/"
             (nth 1
                  (split-string path "scala/")
                  )
             )
    ) ".")
  )

; keybinded functions ;;;;;;;;;;;;;;;;;
(defun sbt-shell-clean-old-output ()
  "When called on a shell buffer this function goes back to the beginning of the last compilation and delete the rest (old compilation)"
  (interactive)
  (funcall 'shell-clean-old-output "[info] Compiling")
  )

(defun scala-goto-next-warn-error (&optional errorMessage backwardSearch)
  "Search into an sbt output for the first warning/error, starting from cursor position, and move to it"
  (interactive)
  (unless errorMessage (setq errorMessage ""))
  (setq searchRegexp (concat ".*\\.scala.*" (regexp-quote errorMessage)))
  (condition-case
      nil
      (funcall (searchFunction backwardSearch) searchRegexp)
    (error (user-error "no match found for %s" errorMessage))
    )
  (sbt-event-file-navigation t)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'goto-line)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'right-char)
  )

(defun scala-import-bounds ()
  "Return the import region bounds"
  (save-excursion
    (search-backward-regexp "\\({\\|import\\)")
    (if (string= (current-word) "import")
        (progn
          (setq startOfImport (point)
                endOfImport (if (char-equal (char-before (line-end-position)) ?{)
                                (progn
                                  (end-of-line)
                                  (cdr (bounds-of-thing-at-point 'sexp)))
                              (line-end-position)
                              ))
          (list startOfImport endOfImport)
          )
      (progn
        (setq endOfImport (cdr (bounds-of-thing-at-point 'sexp)))
        (search-backward-regexp "\\({\\|import\\)")
        (list (point) endOfImport)
        )
      ))
  )

(defun scala-remove-unused-import ()
  "Parse a shell/sbt output in search of the first unused import and remove it"
  (interactive)
  (funcall 'scala-goto-next-warn-error "Unused Import" t)
  (setq bracketImport (line-contains-string ",")
        importPos (save-excursion (search-backward "import ") (point)))
  (if bracketImport
      (progn
        (let (p1 p2 afterComma)
          (condition-case
              nil
              (search-backward "," importPos)
            (error
             (search-backward "{" importPos)
             (forward-char)
             (setq afterComma t)
             )
            )

          (setq p1 (point))
          (forward-word)
          (setq p2 (point))
          (when afterComma (setq p2 (1+ p2)))
          (kill-region p1 p2)))
    (progn
      (beginning-of-line)
      (kill-line)
      (delete-char -1) ;; kill newline
      ;; delete the comma from the previous element of imports
      (when (string= (string (char-before)) ",") (delete-char -1))
      ))
  (setq bracket t)
  (condition-case
      nil
      (search-backward "{")
    (error
     (setq bracket nil)
     )
    )
  (when (and bracket (> (point) importPos))
    (progn
      (setq openBracketPos (point))
      (search-forward "}")
      (setq closedBracketPos (point))
      (setq remainingImports (s-count-matches "\\w+" (buffer-substring openBracketPos closedBracketPos)))
      (message "remainingImports " remainingImports)
      (cond
       (
        (= 0 remainingImports)
        (progn ;; Cleanup import with empty brackets
          (kill-region openBracketPos closedBracketPos)
          (goto-char importPos)
          (beginning-of-buffer)
          (kill-line)
          (delete-char -1)
          ))
       (
        (= 1 remainingImports)
        (save-restriction
          (narrow-to-region importPos closedBracketPos)

          ;; all on one line, only one import remained
          ;; Just join 2 lines together works
          (while (not (= (line-number-at-pos importPos)
                         (line-number-at-pos closedBracketPos)))
            (progn
              (goto-char closedBracketPos)
              (join-line)
              (setq closedBracketPos (point))
              )
            )

          (beginning-of-line)
          (while (search-forward "{" nil t)
            (replace-match ""))
          (beginning-of-line)
          (while (search-forward "}" nil t)
            (replace-match ""))
          (beginning-of-line)
          (search-forward "import ")
          (while (search-forward " " nil t)
            (replace-match ""))
          ))
       )))
  (other-window -1)
  )

(defun scala-import-type-at-point (type)
  "Try to import into the current file the type at point"
  (interactive (list
                (read-string (format "type (%s): " (thing-at-point 'word))
                             nil nil (thing-at-point 'word))))
  (funcall 'build-import
           type
           (lambda (type) (concat "import.*" type "$"))
           (lambda (type) (concat "\\(.*class " inputType ".*\\|.*trait " inputType ".*\\|.*object " inputType ".*\\|.*type " inputType ".*\\)"))
           'scala-build-import-from-existing-import-or-source
           (lambda (result) (save-excursion
                              (beginning-of-buffer)
                              (end-of-line)
                              (next-line)
                              (newline)
                              (insert result)
                              ))
           )
  )

(defun scala-extract-code-line-or-region (name &optional parameters from to)
  "Extract the code to val or def:
   Require:
     - Name of the val/def
     - Optional list of parameters (if empty it will be a val)

   if no code region is selected then it extracts the rest of the line from current position
   Return type not specified.
  "
  (interactive (list
                (read-string "value/function name: " )
                (progn
                  (setq
                   separator (read-string "insert separartor(,): " nil nil ",")
                   param (read-string "param name (RET to finish): ")
                   params nil
                   )
                  (while (not (equal "" (s-trim param)))
                    (push (s-trim param) params)
                    (setq param (read-string "param name (RET to finish): "))
                    )
                  (reverse (cons (car params) (mapcar (lambda (x) (concat x separator)) (cdr params))))
                  )
                (if (use-region-p) (region-beginning) (point))
                (if (use-region-p) (region-end) (line-end-position))
                ))
  (funcall 'extract-code-line-or-region-template "val " "def " " = " " = " nil nil name parameters from to)
  )

(global-set-key (kbd "C-c c s c") 'sbt-shell-clean-old-output)
(global-set-key (kbd "C-c c s e") 'scala-goto-next-warn-error)
(global-set-key (kbd "C-c c s u") 'scala-remove-unused-import)
(global-set-key (kbd "C-c c s p") 'scala-import-type-at-point)
(global-set-key (kbd "C-c c s x") 'scala-extract-code-line-or-region)

#+END_SRC
