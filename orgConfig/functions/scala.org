* Scala

  Functions used specifically for dealing with scala code.
  It depends on the functions defined into `languageTemplateFunctions.org`

#+BEGIN_SRC emacs-lisp :tangle yes
(defun sbt-event-file-navigation (&optional notSplitWindow)
  "Navigate to the file that has a problem. it can navigate using a
  different window."
  (funcall 'event-file-navigation "] " ":" notSplitWindow)
  )

(defun scala-build-import-ag (inputType)
  (setq missingTypeImport nil)
  (ag-project-regexp (concat "import.*\\." type "$"))
  (set-process-sentinel
   (get-process "ag")
   (lexical-let ((type inputType))
     (lambda (p e)
       "A callback attached to ag import"
       (redisplay)
       (switch-to-existing-buffer-other-window "*ag search regexp:import")
       (message "signal first: %s" e)
       (cond
        ((string= e "finished\n") (progn
                                    (compilation-next-error 1)
                                    (search-forward ":import ")
                                    (setq missingTypeStartingPoint (point))
                                    (end-of-line)
                                    (setq missingTypeImport (concat "import " (buffer-substring-no-properties missingTypeStartingPoint (point))))
                                    (switch-to-existing-buffer-other-window "*ag search regexp:import")
                                    (kill-buffer)
                                    ))
        ((string-prefix-p "exited abnormally" e ()) (progn
                                                      (kill-buffer)
                                                      (ag-project-regexp (concat "(.*object " type ".*|.*class " type ".*|.*trait " type ".*|.*type " type ".*)"))
                                                      (set-process-sentinel
                                                       (get-process "ag")
                                                       (lambda (p e)
                                                         "A callback attached to ag types"
                                                         (redisplay)
                                                         (switch-to-existing-buffer-other-window "*ag search regexp:(.*")
                                                         (message "signal second: %s" e)
                                                         (cond
                                                          ((string= e "finished\n") (progn
                                                                                      (setq filePath (funcall 'ag-parsing-first-error-file-path))
                                                                                      (find-file filePath)
                                                                                      (beginning-of-buffer)
                                                                                      (search-forward "package ")
                                                                                      (setq missingTypeStartingPoint (point))
                                                                                      (end-of-line)
                                                                                      (setq
                                                                                       package (buffer-substring-no-properties missingTypeStartingPoint (point))
                                                                                       missingTypeImport (concat "import " package "." type))
                                                                                      (kill-buffer)
                                                                                      ))
                                                          ((string-prefix-p "exited abnormally" e ()) (kill-buffer))
                                                          )))
                                                      ))
        ))))
  (while (accept-process-output (get-process "ag") 0.5))
  (when (> (count-windows) 2) (other-window -1))
  (eval missingTypeImport)
  )

(defun ag-parsing-first-error-file-path ()
  "Parse the ag result buffer and return the first error file path"7
  (compilation-next-error 1)
  (search-backward "File: ")
  (forward-word)
  (forward-char 2)
  (setq dirSPoint (point))
  (end-of-line)
  (setq fileRelativePath (buffer-substring-no-properties dirSPoint (point)))
  (search-backward "default-directory: \"")
  (forward-word 2)
  (forward-char 3)
  (setq dirSPoint (point))
  (search-forward "\"")
  (left-char)
  (setq default-directory (buffer-substring-no-properties dirSPoint (point)))
  (concat default-directory fileRelativePath)
  )

(defun path-to-package (path)
  "transferm a path to a package"
  (interactive)
  (string-join
   (butlast
    (s-split "/"
             (nth 1
                  (split-string path "scala/")
                  )
             )
    ) ".")
  )

; keybinded functions ;;;;;;;;;;;;;;;;;
(defun sbt-shell-clean-old-output ()
  "When called on a shell buffer this function goes back to the beginning of the last compilation and delete the rest (old compilation)"
  (interactive)
  (funcall 'shell-clean-old-output "[info] Compiling")
  )

(defun scala-goto-next-warn-error (&optional errorMessage backwardSearch)
  "Search into an sbt output for the first warning/error, starting from cursor position, and move to it"
  (interactive)
  (unless errorMessage (setq errorMessage ""))
  (setq searchRegexp (concat ".*\\.scala.*" (regexp-quote errorMessage)))
  (condition-case
      nil
      (funcall (searchFunction backwardSearch) searchRegexp)
    (error (user-error "no match found for %s" errorMessage))
    )
  (sbt-event-file-navigation t)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'goto-line)
  (other-window -1)

  (parse-go-to-line-or-column ":" 'right-char)
  )

(defun scala-remove-unused-import ()
  "Parse a shell/sbt output in search of the first unused import and remove it"
  (interactive)
  (funcall 'scala-goto-next-warn-error "Unused Import" t)
  (setq bracketImport (line-contains-string ",")
        importPos (save-excursion (search-backward "import ") (point)))
  (if bracketImport
      (progn
        (let (p1 p2 afterComma)
          (condition-case
              nil
              (search-backward "," importPos)
            (error
             (search-backward "{" importPos)
             (forward-char)
             (setq afterComma t)
             )
            )

          (setq p1 (point))
          (forward-word)
          (setq p2 (point))
          (when afterComma (setq p2 (1+ p2)))
          (kill-region p1 p2)))
    (progn
      (beginning-of-line)
      (kill-line)
      (delete-char -1) ;; kill newline
      ;; delete the comma from the previous element of imports
      (when (string= (string (char-before)) ",") (delete-char -1))
      ))
  (setq bracket t)
  (condition-case
      nil
      (search-backward "{")
    (error
     (setq bracket nil)
     )
    )
  (when (and bracket (> (point) importPos))
    (progn
      (setq openBracketPos (point))
      (search-forward "}")
      (setq closedBracketPos (point))
      (setq remainingImports (s-count-matches "\\w+" (buffer-substring openBracketPos closedBracketPos)))
      (message "remainingImports " remainingImports)
      (cond
       (
        (= 0 remainingImports)
        (progn ;; Cleanup import with empty brackets
          (kill-region openBracketPos closedBracketPos)
          (goto-char importPos)
          (beginning-of-buffer)
          (kill-line)
          (delete-char -1)
          ))
       (
        (= 1 remainingImports)
        (save-restriction
          (narrow-to-region importPos closedBracketPos)

          ;; all on one line, only one import remained
          ;; Just join 2 lines together works
          (while (not (= (line-number-at-pos importPos)
                         (line-number-at-pos closedBracketPos)))
            (progn
              (goto-char closedBracketPos)
              (join-line)
              (setq closedBracketPos (point))
              )
            )

          (beginning-of-line)
          (while (search-forward "{" nil t)
            (replace-match ""))
          (beginning-of-line)
          (while (search-forward "}" nil t)
            (replace-match ""))
          (beginning-of-line)
          (search-forward "import ")
          (while (search-forward " " nil t)
            (replace-match ""))
          ))
       )))
  (other-window -1)
  )

(defun scala-import-type-at-point (type)
  "Try to import into the current file the type at point"
  (interactive (list
                (read-string (format "type (%s): " (thing-at-point 'word))
                             nil nil (thing-at-point 'word))))

  (setq startingBuffer (current-buffer)
        importToAdd (funcall 'scala-build-import-ag type))

  (if importToAdd
      (save-excursion
        (switch-to-buffer startingBuffer)
        (beginning-of-buffer)
        (forward-line)
        (newline)
        (insert importToAdd))
    (user-error "Unable to find import for the type %s" type)
    )
  )

(defun scala-extract-code-line-or-region (name &optional parameters from to)
  "Extract the code to val or def:
   Require:
     - Name of the val/def
     - Optional list of parameters (if empty it will be a val)

   if no code region is selected then it extracts the rest of the line from current position
   Return type not specified.
  "
  (interactive (list
                (read-string "value/function name: " )
                (progn
                  (setq
                   separator (read-string "insert separartor(,): " nil nil ",")
                   param (read-string "param name (RET to finish): ")
                   params nil
                   )
                  (while (not (equal "" (s-trim param)))
                    (push (s-trim param) params)
                    (setq param (read-string "param name (RET to finish): "))
                    )
                  (reverse (cons (car params) (mapcar (lambda (x) (concat x separator)) (cdr params))))
                  )
                (if (use-region-p) (region-beginning) (point))
                (if (use-region-p) (region-end) (line-end-position))
                ))
  (funcall 'extract-code-line-or-region-template "val " "def " " = " " = " nil nil name parameters from to)
  )

(global-set-key (kbd "C-c c s c") 'sbt-shell-clean-old-output)
(global-set-key (kbd "C-c c s e") 'scala-goto-next-warn-error)
(global-set-key (kbd "C-c c s u") 'scala-remove-unused-import)
(global-set-key (kbd "C-c c s p") 'scala-import-type-at-point)
(global-set-key (kbd "C-c c s x") 'scala-extract-code-line-or-region)

#+END_SRC
