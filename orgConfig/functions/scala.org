* Scala

  Functions used specifically for dealing with scala code

  #+BEGIN_SRC emacs-lisp :tangle yes
(defun sbt-event-file-navigation (&optional notSplitWindow)
  "Starting from an sbt output line [info] [warn] or [error] this function:
   - parse the line for the target source file
   - move to the file: it creates a windows if the count-windows is = 1 and the parameter is false
  "
  (beginning-of-line)
  (search-forward "] ")
  (setq filenamePathPos (point))
  (search-forward ":")
  (left-char)
  (setq filePath (buffer-substring filenamePathPos (point)))
  (when (and notSplitWindow (= (count-windows) 1)) (split-window-right))
  (other-window 1)
  (find-file filePath)
  )

(defun scala-goto-next-warn-error (&optional errorMessage backwardSearch)
  "Search into an sbt output for the first warning/error, starting from cursor position, and move to it"
  (interactive)
  ;; Parse and Navigate to file
  (unless errorMessage (setq errorMessage ""))
  (defun searchFunction (backwardDrection)
    (if backwardDrection
        're-search-backward
        're-search-forward
        )
    )
  (defun parse-go-to-line-or-column (gotoFunction)
    "parse line or column starting from an sbt output [info] [warn] or [error]"
    (right-char)
    (setq filenamePathPos (point))
    (search-forward ":")
    (left-char)
    (setq fileLineOrColumn (buffer-substring filenamePathPos (point)))
    (other-window 1)
    (funcall gotoFunction (string-to-number fileLineOrColumn))
    )
  (setq searchRegexp (concat ".*\\.scala.*" (regexp-quote errorMessage)))
  (message "searchRegexp %s - %s - %s" searchRegexp errorMessage backwardSearch)
  (condition-case
      nil
      (funcall (searchFunction backwardSearch) searchRegexp)
      (error (user-error "no match found for %s" errorMessage))
      )
  (sbt-event-file-navigation t)
  (other-window -1)

  (parse-go-to-line-or-column 'goto-line)
  (other-window -1)

  (parse-go-to-line-or-column 'right-char)
  )

(global-set-key (kbd "C-c c s e") 'scala-goto-next-warn-error)

(defun scala-import-type-at-point (type)
  "Try to import into the current file the type at point"
  (interactive (list
                (read-string (format "type (%s): " (thing-at-point 'word))
                             nil nil (thing-at-point 'word))))

  (setq startingBuffer (current-buffer)
        importToAdd (funcall 'scala-build-import-ag type))

  (if importToAdd
      (save-excursion
        (switch-to-buffer startingBuffer)
        (beginning-of-buffer)
        (forward-line)
        (newline)
        (insert importToAdd))
    (user-error "Unable to find import for the type %s" type)
    )
  )

(defun scala-build-import-ag (type)
  (setq missingTypeImport nil)
  (ag-project-regexp (concat "import.*\\." type "$"))
  (set-process-sentinel
   (get-process "ag")
   (lambda (p e)
     "A callback attached to ag import"
     (redisplay)
     (switch-to-existing-buffer-other-window "*ag search regexp:import")
     (when (string= e "finished\n")
       (compilation-next-error 1)
       (search-forward ":import ")
       (setq missingTypeStartingPoint (point))
       (end-of-line)
       (setq missingTypeImport (concat "import " (buffer-substring-no-properties missingTypeStartingPoint (point))))
       )
     ))
  (sleep-for 2)
  (switch-to-existing-buffer-other-window "*ag search regexp:import")
  (kill-buffer)
  (unless missingTypeImport
    (ag-project-regexp (concat "(.*object " type ".*|.*class " type ".*|.*trait " type ".*|.*type " type ".*)"))
    (set-process-sentinel
     (get-process "ag")
     (lambda (p e)
       "A callback attached to ag types"
       (redisplay)
       (switch-to-existing-buffer-other-window "*ag search regexp:(.*")
       (setq agBuffer (current-buffer))
       (when (string= e "finished\n")
         (setq filePath (funcall 'ag-parsing-first-error-file-path))
         (find-file filePath)

         (beginning-of-buffer)
         (search-forward "package ")
         (setq missingTypeStartingPoint (point))
         (end-of-line)
         (setq
          package (buffer-substring-no-properties missingTypeStartingPoint (point))
          missingTypeImport (concat "import " package "." type))
         (kill-buffer)
         )
       ))

    (sleep-for 2)
    (switch-to-existing-buffer-other-window "*ag search regexp:(.*")
    (kill-buffer))
  (when (> (count-windows) 2) (other-window -1))
  (eval missingTypeImport)
  )

(defun ag-parsing-first-error-file-path ()
  "Parse the ag result buffer and return the first error file path"7
  (compilation-next-error 1)
  (search-backward "File: ")
  (forward-word)
  (forward-char 2)
  (setq dirSPoint (point))
  (end-of-line)
  (setq fileRelativePath (buffer-substring-no-properties dirSPoint (point)))
  (search-backward "default-directory: \"")
  (forward-word 2)
  (forward-char 3)
  (setq dirSPoint (point))
  (search-forward "\"")
  (left-char)
  (setq default-directory (buffer-substring-no-properties dirSPoint (point)))
  (concat default-directory fileRelativePath)
  )

(defun scala-import-type-not-found ()
  "Search into an sbt output for the first missing import, search the for the type, copy the right import and add it to the failing file"
  (interactive)
  (search-forward-regexp "not found: \\(type\\|value\\) ")
  (setq type (thing-at-point 'word)
        startingBuffer (current-buffer))
  (forward-line -2)
  (funcall 'scala-goto-next-warn-error)
  (setq missingImport (funcall 'scala-build-import-ag type))
  (sleep-for 2)
  (switch-to-buffer startingBuffer)
  (when missingImport
    (sbt-event-file-navigation)

    (beginning-of-buffer)
    (next-line)
    (newline)
    (insert missingTypeImport)
    (other-window -1)
    (switch-to-buffer startingBuffer))
  )

(global-set-key (kbd "C-c c s i") 'scala-import-type-not-found)
(global-set-key (kbd "C-c c s p") 'scala-import-type-at-point)

(defun scala-remove-unused-import ()
  "Parse a shell/sbt output in search of the first unused import and remove it"
  (interactive)
  (funcall 'scala-goto-next-warn-error "Unused Import" t)
  (setq bracketImport (line-contains-string ",")
        importPos (save-excursion (search-backward "import ") (point)))
  (if bracketImport
      (progn
        (let (p1 p2 afterComma)
          (condition-case
              nil
              (search-backward "," importPos)
            (error
             (search-backward "{" importPos)
             (forward-char)
             (setq afterComma t)
             )
            )

          (setq p1 (point))
          (forward-word)
          (setq p2 (point))
          (when afterComma (setq p2 (1+ p2)))
          (kill-region p1 p2)))
    (progn
      (beginning-of-line)
      (kill-line)
      (delete-char -1) ;; kill newline
      ;; delete the comma from the previous element of imports
      (when (string= (string (char-before)) ",") (delete-char -1))
      ))
 (setq noBracket nil)
 (condition-case
     nil
     (search-backward "{")
   (error
     (setq noBracket t)
     )
   )
 (when (and noBracket (> (point) importPos))
   (progn
     (setq openBracketPos (point))
     (search-forward "}")
     (setq closedBracketPos (point))
     (setq remainingImports (s-count-matches "\\w+" (buffer-substring openBracketPos closedBracketPos)))
     (message "remainingImports " remainingImports)
     (cond
      (
       (= 0 remainingImports)
       (progn ;; Cleanup import with empty brackets
         (kill-region openBracketPos closedBracketPos)
         (goto-char importPos)
         (beginning-of-buffer)
         (kill-line)
         (delete-char -1)
         ))
      (
       (= 1 remainingImports)
         (save-restriction
           (narrow-to-region importPos closedBracketPos)

           ;; all on one line, only one import remained
           ;; Just join 2 lines together works
           (while (not (= (line-number-at-pos importPos)
                         (line-number-at-pos closedBracketPos)))
             (progn
               (goto-char closedBracketPos)
               (join-line)
               (setq closedBracketPos (point))
               )
             )

           (beginning-of-line)
           (while (search-forward "{" nil t)
             (replace-match ""))
           (beginning-of-line)
           (while (search-forward "}" nil t)
             (replace-match ""))
           (beginning-of-line)
           (search-forward "import ")
           (while (search-forward " " nil t)
             (replace-match ""))
           ))
    )))
  (other-window -1)
  )

(global-set-key (kbd "C-c c s u") 'scala-remove-unused-import)

(defun line-contains-string (args)
  "Check if the current line contains the input string"
  (save-excursion
    (beginning-of-line)
    (when (search-forward args (line-end-position) t) t)
    )
  )
  #+END_SRC
